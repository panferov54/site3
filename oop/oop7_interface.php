<?php
//интерфейс - абстрактный объект который может содержать свойства и методы, НО обязательно без реализации
//не может содержать свойства(в отличие от класса абсракт) но может содержать константу. Интерфейсы могут быть реализованны классами, которые их реализуеют(имплементс)
//если какойто класс реализует интерфейс,то он обязан реализовать все методы интерфейса, класс может реализовывать несколько интерфейосов

//когда использовать абстракт , а когда через интерфейс:
//если в базовом типе надо менять не только методы но и свойства тогда мы должны выбрать абстрактный класс
//если мы хотим свою иерархию более гибкой и м аштабируемой лучше использовать несколько интерфейсов и реализовывать их


interface Geometry {
   const Pi=M_PI;


    function Area();
    function Perimetr();
}
 class Point{

    public $x;
    public $y;

    function __construct($x1,$y1)
    {
        $this->x=$x1;
        $this->y=$y1;
    }

    function Show(){
        echo "<br>Vertex:($this->x,$this->y)";
    }

}
//подключение интерфейса
class Rectangle extends Point implements Geometry {
    public $width;
    public $height;
    function __construct($x1, $y1,$w,$h)
    {
        parent::__construct($x1, $y1);
        $this->width=$w;
        $this->height=$h;
    }
//переопределение функции
    function Show()
    {
        parent::Show(); // TODO: Change the autogenerated stub
        echo "<br>Width:$this->width,Height: $this->height";
    }

    function Area(){
        return $this->width*$this->height;
    }

    function Perimetr(){
        return ($this->width+$this->height )*2;
    }
}


class Circle extends Point implements Geometry {
    public $radius;
    function __construct($x1, $y1,$r)
    {
        parent::__construct($x1, $y1);
        $this->radius=$r;
    }
    function Show()
    {
        parent::Show();
        echo "radius: $this->radius";
    }

    function Area(){
        return Geometry::Pi*pow($this->radius,2);
    }

    function Perimetr(){
        return 2*Geometry::Pi*$this->radius;
    }


}